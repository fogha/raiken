name: Deploy to Server

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
      security-events: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Deploy to Contabo Server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.CONTABO_HOST }}
          username: ${{ secrets.CONTABO_USERNAME }}
          key: ${{ secrets.CONTABO_SSH_KEY }}
          script: |
            set -e

            # Vars
            APP_NAME="raiken"
            APP_DIR="/opt/$APP_NAME"
            DOCKER_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"

            echo "🚀 Starting deployment of $APP_NAME..."

            # Ensure app dir
            sudo mkdir -p "$APP_DIR"
            cd "$APP_DIR"

            # GHCR login (GITHUB_TOKEN as requested)
            echo "🔐 Logging into GitHub Container Registry..."
            echo "${{ secrets.GITHUB_TOKEN }}" | sudo docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

            # Pull image
            echo "📥 Pulling latest Docker image..."
            sudo docker pull "$DOCKER_IMAGE"

            # Stop existing stack (Compose V2)
            echo "🛑 Stopping existing containers..."
            sudo docker compose down || true

            # Compose file (create if missing)
            if [ ! -f docker-compose.yml ]; then
              echo "📝 Creating docker-compose.yml..."
              sudo tee docker-compose.yml > /dev/null <<EOF
            version: '3.8'
            services:
              app:
                image: $DOCKER_IMAGE
                container_name: $APP_NAME-app
                restart: unless-stopped
                environment:
                  - NODE_ENV=production
                  - OPENROUTER_API_KEY=${{ secrets.OPENROUTER_API_KEY }}
                  - NEXT_PUBLIC_BASE_URL=${{ secrets.NEXT_PUBLIC_BASE_URL }}
                  - NEXT_PUBLIC_APP_VERSION=${{ github.sha }}
                  - RAIKEN_ENABLE_AI_ANALYSIS=true
                ports:
                  - "3000:3000"
                volumes:
                  - ./data:/app/data
                  - ./logs:/app/logs
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:3000"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
                  start_period: 40s
            EOF
            fi

            # Ensure correct image line (idempotent)
            sudo sed -i "s|^\s*image:\s*.*|    image: $DOCKER_IMAGE|g" docker-compose.yml

            # Start app
            sudo docker compose up -d

            # Wait and health check
            sleep 30
            if curl -f -s http://localhost:3000 > /dev/null; then
              echo "✅ Application is healthy!"
            else
              echo "❌ Health check failed!"
              sudo docker compose logs --tail=20
              exit 1
            fi

            # Cleanup old images
            sudo docker image prune -f

      - name: Setup SSL Certificate (Optional)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.CONTABO_HOST }}
          username: ${{ secrets.CONTABO_USERNAME }}
          key: ${{ secrets.CONTABO_SSH_KEY }}
          port: ${{ secrets.CONTABO_PORT }}
          script: |
            set -e
            APP_DOMAIN="${{ secrets.APP_DOMAIN }}"
            
            if [ -z "$APP_DOMAIN" ]; then
              echo "No domain configured, skipping SSL setup"
              exit 0
            fi

            echo "Setting up SSL certificate for $APP_DOMAIN..."

            if ! command -v certbot >/dev/null 2>&1; then
              sudo apt-get update -y
              sudo apt-get install -y certbot python3-certbot-nginx
            fi

            if [ -d "/etc/letsencrypt/live/$APP_DOMAIN" ]; then
              sudo certbot renew --quiet
            else
              sudo certbot --nginx -d "$APP_DOMAIN" --non-interactive --agree-tos --email "${{ secrets.ADMIN_EMAIL }}"
            fi

            (crontab -l 2>/dev/null; echo "0 12 * * * /usr/bin/certbot renew --quiet") | crontab -

      - name: Configure Nginx
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.CONTABO_HOST }}
          username: ${{ secrets.CONTABO_USERNAME }}
          key: ${{ secrets.CONTABO_SSH_KEY }}
          port: ${{ secrets.CONTABO_PORT }}
          script: |
            set -e
            APP_DOMAIN="${{ secrets.APP_DOMAIN }}"
            if [ -z "$APP_DOMAIN" ]; then 
              APP_DOMAIN="default"
            fi

            NGINX_CONFIG="/etc/nginx/sites-available/$APP_DOMAIN"
            NGINX_ENABLED="/etc/nginx/sites-enabled/$APP_DOMAIN"

            # Check if SSL certificates exist and domain is configured
            if [ -f "/etc/letsencrypt/live/$APP_DOMAIN/fullchain.pem" ] && [ "$APP_DOMAIN" != "default" ]; then
              sudo tee "$NGINX_CONFIG" > /dev/null <<EOF
            server {
                listen 80;
                server_name $APP_DOMAIN;
                return 301 https://\$server_name\$request_uri;
            }
            server {
                listen 443 ssl http2;
                server_name $APP_DOMAIN;

                ssl_certificate /etc/letsencrypt/live/$APP_DOMAIN/fullchain.pem;
                ssl_certificate_key /etc/letsencrypt/live/$APP_DOMAIN/privkey.pem;
                ssl_protocols TLSv1.2 TLSv1.3;
                ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
                ssl_prefer_server_ciphers off;
                ssl_session_cache shared:SSL:10m;
                ssl_session_timeout 10m;

                add_header X-Frame-Options DENY;
                add_header X-Content-Type-Options nosniff;
                add_header X-XSS-Protection "1; mode=block";
                add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

                gzip on;
                gzip_vary on;
                gzip_min_length 1024;
                gzip_proxied any;
                gzip_comp_level 6;
                gzip_types
                    text/plain
                    text/css
                    text/xml
                    text/javascript
                    application/json
                    application/javascript
                    application/xml+rss
                    application/atom+xml
                    image/svg+xml;

                location / {
                    proxy_pass http://localhost:3000;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade \$http_upgrade;
                    proxy_set_header Connection 'upgrade';
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                    proxy_cache_bypass \$http_upgrade;
                    proxy_read_timeout 86400;
                }

                location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
                    proxy_pass http://localhost:3000;
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                    expires 1y;
                    add_header Cache-Control "public, immutable";
                }

                location /health {
                    access_log off;
                    return 200 "healthy\n";
                    add_header Content-Type text/plain;
                }
            }
            EOF
            else
              sudo tee "$NGINX_CONFIG" > /dev/null <<EOF
            server {
                listen 80 default_server;
                server_name _;

                location / {
                    proxy_pass http://localhost:3000;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade \$http_upgrade;
                    proxy_set_header Connection 'upgrade';
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                    proxy_cache_bypass \$http_upgrade;
                    proxy_read_timeout 86400;
                }

                location /health {
                    access_log off;
                    return 200 "healthy\n";
                    add_header Content-Type text/plain;
                }
            }
            EOF
            fi

            sudo ln -sf "$NGINX_CONFIG" "$NGINX_ENABLED"
            sudo nginx -t
            sudo systemctl reload nginx

      - name: Final Health Check
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.CONTABO_HOST }}
          username: ${{ secrets.CONTABO_USERNAME }}
          key: ${{ secrets.CONTABO_SSH_KEY }}
          port: ${{ secrets.CONTABO_PORT }}
          script: |
            set -e
            APP_DOMAIN="${{ secrets.APP_DOMAIN }}"
            if [ -z "$APP_DOMAIN" ]; then APP_DOMAIN="raiken"; fi

            sleep 10

            # Check if domain is configured
            if [ -n "$APP_DOMAIN" ] && [ "$APP_DOMAIN" != "default" ]; then
              if curl -f -s "https://$APP_DOMAIN" > /dev/null; then
                echo "✅ App accessible via HTTPS: https://$APP_DOMAIN"
              else
                if curl -f -s "http://$APP_DOMAIN" > /dev/null; then
                  echo "✅ App accessible via HTTP: http://$APP_DOMAIN"
                else
                  echo "❌ App not accessible"
                  sudo docker compose ps
                  exit 1
                fi
              fi
            else
              if curl -f -s "http://localhost:3000" > /dev/null; then
                echo "✅ App running on localhost:3000"
              else
                echo "❌ App not accessible"
                sudo docker compose ps
                exit 1
              fi
            fi
