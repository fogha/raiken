name: Deploy to Server

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
      security-events: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Deploy application (Docker Compose)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.CONTABO_HOST }}
          username: ${{ secrets.CONTABO_USERNAME }}
          key: ${{ secrets.CONTABO_SSH_KEY }}
          port: ${{ secrets.CONTABO_PORT }}
          script: |
            set -e

            APP_NAME="raiken"
            APP_DIR="/opt/$APP_NAME"
            DOCKER_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"

            echo "üöÄ Deploying $APP_NAME ..."
            sudo mkdir -p "$APP_DIR"
            cd "$APP_DIR"

            echo "üîê Logging into GHCR..."
            echo "${{ secrets.GITHUB_TOKEN }}" | sudo docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

            echo "üì• Pulling image: $DOCKER_IMAGE"
            sudo docker pull "$DOCKER_IMAGE"

            echo "üõë Bringing down current stack (if any)"
            sudo docker compose down || true

            if [ ! -f docker-compose.yml ]; then
              echo "üìù Creating docker-compose.yml..."
              sudo tee docker-compose.yml > /dev/null <<EOF
            version: '3.8'
            services:
              app:
                image: $DOCKER_IMAGE
                container_name: ${APP_NAME}-app
                restart: unless-stopped
                environment:
                  - NODE_ENV=production
                  - OPENROUTER_API_KEY=${{ secrets.OPENROUTER_API_KEY }}
                  - NEXT_PUBLIC_BASE_URL=${{ secrets.NEXT_PUBLIC_BASE_URL }}
                  - NEXT_PUBLIC_APP_VERSION=${{ github.sha }}
                  - RAIKEN_ENABLE_AI_ANALYSIS=true
                ports:
                  - "3000:3000"
                volumes:
                  - ./data:/app/data
                  - ./logs:/app/logs
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:3000"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
                  start_period: 40s
            EOF
            fi

            # Ensure the image line is current (idempotent)
            sudo sed -i "s|^\s*image:\s*.*|    image: $DOCKER_IMAGE|g" docker-compose.yml

            echo "‚¨ÜÔ∏è  Starting app stack..."
            sudo docker compose up -d

            echo "‚è≥ Waiting for app..."
            sleep 30
            if curl -f -s http://localhost:3000 > /dev/null; then
              echo "‚úÖ App is healthy on http://localhost:3000"
            else
              echo "‚ùå App health check failed; recent logs:"
              sudo docker compose logs --tail=50
              exit 1
            fi

            echo "üßπ Pruning old images..."
            sudo docker image prune -f

      - name: Configure Nginx (HTTP only for ACME)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.CONTABO_HOST }}
          username: ${{ secrets.CONTABO_USERNAME }}
          key: ${{ secrets.CONTABO_SSH_KEY }}
          port: ${{ secrets.CONTABO_PORT }}
          script: |
            set -e
            APP_DOMAIN="${{ secrets.APP_DOMAIN }}"
            if [ -z "$APP_DOMAIN" ]; then
              echo "‚ÑπÔ∏è No APP_DOMAIN set; installing default HTTP site."
              APP_DOMAIN="default"
            fi

            # Remove any enabled site that references missing certs to avoid nginx -t failure
            if sudo nginx -T 2>/dev/null | grep -q "/etc/letsencrypt/live/$APP_DOMAIN/fullchain.pem"; then
              echo "üßπ Disabling stale SSL site temporarily..."
              sudo rm -f "/etc/nginx/sites-enabled/$APP_DOMAIN" || true
            fi

            echo "üîß Writing HTTP-only site for $APP_DOMAIN (serves ACME + proxies app)"
            sudo mkdir -p /var/www/certbot
            sudo chown -R www-data:www-data /var/www/certbot

            NGINX_CONFIG="/etc/nginx/sites-available/$APP_DOMAIN"
            NGINX_ENABLED="/etc/nginx/sites-enabled/$APP_DOMAIN"

            # If APP_DOMAIN is 'default', use wildcard server; else use server_name
            if [ "$APP_DOMAIN" = "default" ]; then
              sudo tee "$NGINX_CONFIG" > /dev/null <<'EOF'
            server {
                listen 80 default_server;
                server_name _;

                # ACME placeholder (kept for uniformity)
                location /.well-known/acme-challenge/ {
                    root /var/www/certbot;
                }

                location / {
                    proxy_pass http://localhost:3000;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade $http_upgrade;
                    proxy_set_header Connection 'upgrade';
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                    proxy_read_timeout 86400;
                }

                location /health {
                    access_log off;
                    return 200 "healthy\n";
                    add_header Content-Type text/plain;
                }
            }
            EOF
            else
              sudo tee "$NGINX_CONFIG" > /dev/null <<EOF
            server {
                listen 80;
                server_name $APP_DOMAIN;

                # ACME webroot for Certbot
                location /.well-known/acme-challenge/ {
                    root /var/www/certbot;
                }

                # Proxy to app (no SSL yet)
                location / {
                    proxy_pass http://localhost:3000;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade \$http_upgrade;
                    proxy_set_header Connection 'upgrade';
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                    proxy_read_timeout 86400;
                }
            }
            EOF
            fi

            sudo ln -sf "$NGINX_CONFIG" "$NGINX_ENABLED"
            echo "üß™ nginx -t"
            sudo nginx -t
            echo "üîÑ Reloading Nginx..."
            sudo systemctl reload nginx
            echo "‚úÖ HTTP config ready."

      - name: Setup SSL certificate (webroot)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.CONTABO_HOST }}
          username: ${{ secrets.CONTABO_USERNAME }}
          key: ${{ secrets.CONTABO_SSH_KEY }}
          port: ${{ secrets.CONTABO_PORT }}
          script: |
            set -e
            APP_DOMAIN="${{ secrets.APP_DOMAIN }}"
            ADMIN_EMAIL="${{ secrets.ADMIN_EMAIL }}"

            if [ -z "$APP_DOMAIN" ]; then
              echo "‚ÑπÔ∏è No APP_DOMAIN set; skipping SSL issuance."
              exit 0
            fi
            if [ -z "$ADMIN_EMAIL" ]; then
              echo "‚ùå ADMIN_EMAIL must be set to obtain a certificate."
              exit 1
            fi

            echo "üîí Ensuring certbot installed..."
            if ! command -v certbot >/dev/null 2>&1; then
              sudo apt-get update -y
              sudo apt-get install -y certbot
            fi

            echo "üìÅ Ensuring ACME webroot exists..."
            sudo mkdir -p /var/www/certbot
            sudo chown -R www-data:www-data /var/www/certbot

            if [ -d "/etc/letsencrypt/live/$APP_DOMAIN" ]; then
              echo "üîÑ Renewing existing certificate..."
              sudo certbot renew --quiet
            else
              echo "üÜï Obtaining new certificate via webroot for $APP_DOMAIN ..."
              sudo certbot certonly --webroot \
                -w /var/www/certbot \
                -d "$APP_DOMAIN" \
                --email "$ADMIN_EMAIL" \
                --agree-tos --non-interactive
            fi

            echo "‚è∞ Setting up auto-renew + nginx reload..."
            (crontab -l 2>/dev/null; echo "0 3 * * * /usr/bin/certbot renew --quiet && /usr/sbin/nginx -s reload") | crontab -
            echo "‚úÖ Certificate available at /etc/letsencrypt/live/$APP_DOMAIN/"

      - name: Configure Nginx (enable HTTPS)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.CONTABO_HOST }}
          username: ${{ secrets.CONTABO_USERNAME }}
          key: ${{ secrets.CONTABO_SSH_KEY }}
          port: ${{ secrets.CONTABO_PORT }}
          script: |
            set -e
            APP_DOMAIN="${{ secrets.APP_DOMAIN }}"
            if [ -z "$APP_DOMAIN" ]; then
              echo "‚ÑπÔ∏è No APP_DOMAIN set; keeping default HTTP site."
              exit 0
            fi

            if [ ! -f "/etc/letsencrypt/live/$APP_DOMAIN/fullchain.pem" ]; then
              echo "‚ùå Cert not found for $APP_DOMAIN; cannot enable HTTPS yet."
              exit 1
            fi

            echo "üîß Writing HTTPS + redirect for $APP_DOMAIN ..."
            NGINX_CONFIG="/etc/nginx/sites-available/$APP_DOMAIN"
            sudo tee "$NGINX_CONFIG" > /dev/null <<EOF
            # HTTP: keep ACME challenges, redirect the rest to HTTPS
            server {
                listen 80;
                server_name $APP_DOMAIN;

                location /.well-known/acme-challenge/ {
                    root /var/www/certbot;
                }

                location / {
                    return 301 https://\$host\$request_uri;
                }
            }

            # HTTPS: proxy to the app
            server {
                listen 443 ssl http2;
                server_name $APP_DOMAIN;

                ssl_certificate     /etc/letsencrypt/live/$APP_DOMAIN/fullchain.pem;
                ssl_certificate_key /etc/letsencrypt/live/$APP_DOMAIN/privkey.pem;
                ssl_protocols TLSv1.2 TLSv1.3;

                add_header X-Frame-Options DENY;
                add_header X-Content-Type-Options nosniff;
                add_header X-XSS-Protection "1; mode=block";
                add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

                location / {
                    proxy_pass http://localhost:3000;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade \$http_upgrade;
                    proxy_set_header Connection 'upgrade';
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                    proxy_read_timeout 86400;
                }

                location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
                    proxy_pass http://localhost:3000;
                    proxy_set_header Host \$host;
                    expires 1y;
                    add_header Cache-Control "public, immutable";
                }

                location /health {
                    access_log off;
                    return 200 "healthy\n";
                    add_header Content-Type text/plain;
                }
            }
            EOF

            sudo ln -sf "$NGINX_CONFIG" "/etc/nginx/sites-enabled/$APP_DOMAIN"
            echo "üß™ nginx -t"
            sudo nginx -t
            echo "üîÑ Reloading Nginx..."
            sudo systemctl reload nginx
            echo "‚úÖ HTTPS enabled for $APP_DOMAIN"

      - name: Final health check
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.CONTABO_HOST }}
          username: ${{ secrets.CONTABO_USERNAME }}
          key: ${{ secrets.CONTABO_SSH_KEY }}
          port: ${{ secrets.CONTABO_PORT }}
          script: |
            set -e
            APP_DOMAIN="${{ secrets.APP_DOMAIN }}"
            echo "üîç Final health check..."
            sleep 10

            if [ -n "$APP_DOMAIN" ]; then
              if curl -f -s "https://$APP_DOMAIN" > /dev/null; then
                echo "‚úÖ Accessible via HTTPS: https://$APP_DOMAIN"
                exit 0
              fi
              if curl -f -s "http://$APP_DOMAIN" > /dev/null; then
                echo "‚ö†Ô∏è Accessible via HTTP but not HTTPS: http://$APP_DOMAIN"
                exit 0
              fi
              echo "‚ùå Not accessible at domain: $APP_DOMAIN"
              sudo docker compose ps || true
              exit 1
            else
              if curl -f -s "http://localhost:3000" > /dev/null; then
                echo "‚úÖ App running on localhost:3000"
              else
                echo "‚ùå App not accessible locally"
                sudo docker compose ps || true
                exit 1
              fi
            fi
